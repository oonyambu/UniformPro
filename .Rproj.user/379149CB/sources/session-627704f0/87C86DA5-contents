# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @useDynLib UniformPro, .registration=TRUE
NULL

#'	@exportPattern "^[[:alpha:]]+"
NULL

#' William transformation using C-->C++
#' @param x The Design matrix x
#' @name WilliamC
#' @export
#' @import Rcpp
WilliamC <- function(x) {
    .Call(`_UniformPro_WilliamC`, x)
}

#' William transformation 
#' @param x The Design matrix x
#' @name WilliamCpp
#' @export
William <- function(x) {
    .Call(`_UniformPro_William`, x)
}

#' Inverse William transformation
#' @param x The Design matrix x
#' @param levels The number of levels in the design
#' @name WilliamInv
#' @export
WilliamInv <- function(x, levels) {
    .Call(`_UniformPro_WilliamInv`, x, levels)
}

#' The L2 distance of design matrix x. min{d_p(x_i,x_j), 1<=i<j<=n}
#' equation 2.1
#' @param x The Design matrix x
#' @name d2
#' @export
d2 <- function(x) {
    .Call(`_UniformPro_d2`, x)
}

#' average of the absolute correlations between columns
#' Design is orthogonal if rho_ave(D) == 0
#' @name rho_ave
#' @param x The design matrix D
#' @export
rho_ave <- function(x) {
    .Call(`_UniformPro_rho_ave`, x)
}

#' Centered L2 discrepancy -- Equation 2.3
#' @param y Input Design Matrix
#' @name CD
#' @export
CD <- function(y) {
    .Call(`_UniformPro_CD`, y)
}

#' Centered L2 discrepancy using C-->C++
#' The vector x is read in rowwise rather than columnwise.
#' To Obtain the correct values, you should transpose the matrix
#' @param x The design matrix D
#' @name CD2
#' @export
CD2 <- function(x) {
    .Call(`_UniformPro_CD2`, x)
}

#' Construct N x (N - 1) good lattice points
#'
#' @name construct
#' @param n Number of rows for the final design. SHOULD BE PRIME
#' @return design d with n rows, n levels, n - 1 columns
#' @export
construct <- function(n) {
    .Call(`_UniformPro_construct`, n)
}

#' Compute phi value for design D . Check equation 3.1 Uniform Projection
#' Designs paper combn + mean.
#' 
#' @name phi 
#' @param x input design D
#' @param k number of dimensions to be projected onto
#' @export
phi <- function(x, k) {
    .Call(`_UniformPro_phi`, x, k)
}

#' Used Combn + reduce function.
#' 
#' @param x the design matrix x
#' @param k the number of dimensions to be projected onto.
#' @name phi2
#' @export
phi2 <- function(x, k) {
    .Call(`_UniformPro_phi2`, x, k)
}

#' Used while loop.
#' @name phi3
#' @param x the design matrix d
#' @param k the number of dimensions to be projected onto.
#' @export
phi3 <- function(x, k) {
    .Call(`_UniformPro_phi3`, x, k)
}

#' Compute phi value for design D . Check equation 3.1 Uniform Projection
#' Designs paper
#' 
#' Assumes we are only interested in 2d projection
#' 
#' @name phi2D
#' @param x input design D
#' @param s The level for the design matrix D
#' @export
phi2D <- function(x, s) {
    .Call(`_UniformPro_phi2D`, x, s)
}

#' Computes the phi efficiency.
#' @name phi efficiency
#' @param x Design matrix x
#' @export
phiEff <- function(x) {
    .Call(`_UniformPro_phiEff`, x)
}

#' Computes psi -- combn fn
#' @export
#' @name psi
#' @param x Design matrix x 
psi <- function(x) {
    .Call(`_UniformPro_psi`, x)
}

#' Computes psi -- double for loop
#'  @name psi2
#' @param x Design matrix x 
#' @export
psi2 <- function(x) {
    .Call(`_UniformPro_psi2`, x)
}

